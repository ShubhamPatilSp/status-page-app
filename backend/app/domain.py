from typing import List, Optional, Union, Any, ForwardRef
from enum import Enum
from datetime import datetime, timezone
from bson import ObjectId
from pydantic import BaseModel, Field, EmailStr, HttpUrl, GetCoreSchemaHandler, ConfigDict # Import GetCoreSchemaHandler from pydantic
from pydantic.json_schema import JsonSchemaValue, GetJsonSchemaHandler as GetJsonSchemaHandlerForJson # Alias to avoid name clash if needed, or remove if GetJsonSchemaHandler from pydantic.json_schema is not used elsewhere
from pydantic_core import core_schema

# Helper for MongoDB ObjectId
class PyObjectId(ObjectId):
    @classmethod
    def __get_pydantic_core_schema__(
        cls,
        source_type: Any,
        handler: GetCoreSchemaHandler # Use the directly imported GetCoreSchemaHandler
    ) -> core_schema.CoreSchema:
        """
        Return a Pydantic CoreSchema that defines how to validate and serialize ObjectIds.
        - Validates that the input is a valid ObjectId string or an ObjectId instance.
        - Serializes ObjectId instances to strings.
        """
        def validate_from_str(value: str) -> ObjectId:
            if not ObjectId.is_valid(value):
                raise ValueError("Invalid ObjectId format")
            return ObjectId(value)

        from_python_schema = core_schema.union_schema(
            [
                core_schema.is_instance_schema(ObjectId),
                core_schema.no_info_plain_validator_function(validate_from_str),
            ],
            serialization=core_schema.to_string_ser_schema(),
        )

        return core_schema.json_or_python_schema(
            json_schema=core_schema.no_info_plain_validator_function(validate_from_str),
            python_schema=from_python_schema,
            serialization=core_schema.to_string_ser_schema(),
        )

    @classmethod
    def __get_pydantic_json_schema__(
        cls,
        core_schema_obj: core_schema.CoreSchema, # Retain core_schema_obj for clarity if needed by handler
        handler: GetJsonSchemaHandlerForJson # Use aliased GetJsonSchemaHandlerForJson for __get_pydantic_json_schema__
    ) -> JsonSchemaValue:
        # The core_schema_obj passed here is the one generated by __get_pydantic_core_schema__
        # We just need to ensure the JSON schema type is 'string' and provide an example.
        json_schema = handler(core_schema_obj) # Call the handler with the schema from core_schema
        # Ensure the schema reflects that it's a string representation of ObjectId
        # The actual schema structure might be more complex due to union_schema, 
        # but for JSON schema, we primarily care about its representation.
        # Pydantic V2 typically handles this well, but we can enforce string type if necessary.
        # For example, if the handler doesn't automatically set it to string based on serialization:
        # if 'type' not in json_schema or json_schema['type'] != 'string':
        #     json_schema = {}
        #     json_schema.update(type='string')
        # else: # if it's already a good schema, just add example
        #     pass
        # Simpler approach: Pydantic's default string schema for serialization is usually sufficient.
        # We just add an example.
        json_schema.update(
            type='string', # Explicitly state it's a string in JSON schema
            example='507f1f77bcf86cd799439011'
        )
        return json_schema

# Enums
class ServiceStatusEnum(str, Enum):
    OPERATIONAL = "Operational"
    DEGRADED_PERFORMANCE = "Degraded Performance"
    PARTIAL_OUTAGE = "Partial Outage"
    MAJOR_OUTAGE = "Major Outage"
    MAINTENANCE = "Under Maintenance"
    MINOR_OUTAGE = "Minor Outage"

class IncidentStatusEnum(str, Enum):
    INVESTIGATING = "Investigating"
    IDENTIFIED = "Identified"
    MONITORING = "Monitoring"
    RESOLVED = "Resolved"
    SCHEDULED = "Scheduled" # For scheduled maintenance

class IncidentSeverityEnum(str, Enum):
    CRITICAL = "Critical"
    MAJOR = "Major"
    MINOR = "Minor"

class UserRoleEnum(str, Enum):
    ADMIN = "admin"
    MEMBER = "member"
    VIEWER = "viewer"

# Base Model for MongoDB documents
class MongoBaseModel(BaseModel):
    id: Optional[PyObjectId] = Field(default_factory=PyObjectId, alias="_id")

    model_config = {
        "populate_by_name": True,
        "arbitrary_types_allowed": True
    }

# User Models
class User(BaseModel):
    id: PyObjectId = Field(default_factory=PyObjectId, alias="_id")
    auth0_id: str
    email: EmailStr
    name: Optional[str] = None
    picture: Optional[str] = None
    organization_ids: List[PyObjectId] = []
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

class Subscriber(BaseModel):
    id: PyObjectId = Field(default_factory=PyObjectId, alias="_id")
    email: EmailStr
    organization_id: PyObjectId
    created_at: datetime = Field(default_factory=datetime.utcnow)

class OrganizationMember(BaseModel):
    user_id: PyObjectId
    role: UserRoleEnum = UserRoleEnum.MEMBER

class Organization(MongoBaseModel):
    name: str = Field(..., min_length=1, max_length=100)
    slug: str = Field(..., unique=True, index=True)
    owner_id: PyObjectId
    members: List[OrganizationMember] = []
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

class TeamMember(BaseModel):
    user_id: PyObjectId
    role: UserRoleEnum = UserRoleEnum.MEMBER

class Team(MongoBaseModel):
    name: str = Field(..., min_length=1, max_length=100)
    organization_id: PyObjectId
    members: List[TeamMember] = []
    description: Optional[str] = None
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

class ServiceStatusHistory(BaseModel):
    id: PyObjectId = Field(default_factory=PyObjectId, alias="_id")
    old_status: Optional[ServiceStatusEnum] = None
    new_status: ServiceStatusEnum
    timestamp: datetime = Field(default_factory=datetime.utcnow)

# Service Management Models
class Service(MongoBaseModel):
    # Using model_config directly in Pydantic v2
    model_config = ConfigDict(
        populate_by_name=True,
        arbitrary_types_allowed=True,
        json_encoders={
            ObjectId: str
        },
    )

    id: PyObjectId = Field(alias="_id")
    name: str = Field(..., min_length=1, max_length=100)
    organization_id: PyObjectId
    description: Optional[str] = None
    status: ServiceStatusEnum = ServiceStatusEnum.OPERATIONAL
    status_history: List[ServiceStatusHistory] = []
    tags: List[str] = []
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None

# Incident/Maintenance Management Models


class Subscriber(BaseModel):
    id: PyObjectId = Field(default_factory=PyObjectId, alias="_id")
    email: EmailStr
    organization_id: PyObjectId
    created_at: datetime = Field(default_factory=datetime.utcnow)

    class Config:
        populate_by_name = True
        json_encoders = {ObjectId: str}

class IncidentUpdate(BaseModel): 
    message: str
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    posted_by_id: Optional[PyObjectId] = None 

class Incident(MongoBaseModel):
    title: str = Field(..., min_length=1, max_length=200)
    organization_id: PyObjectId
    status: IncidentStatusEnum = IncidentStatusEnum.INVESTIGATING
    severity: IncidentSeverityEnum = IncidentSeverityEnum.MINOR
    affected_services: List[PyObjectId]
    updates: List[IncidentUpdate] = []
    is_maintenance: bool = False
    scheduled_start_time: Optional[datetime] = None
    scheduled_end_time: Optional[datetime] = None
    resolved_at: Optional[datetime] = None
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

# --- API Request Body Models (for Create/Update operations) ---

class UserCreate(BaseModel):
    auth0_id: str
    email: EmailStr
    name: Optional[str] = None
    picture: Optional[HttpUrl] = None

class OrganizationCreate(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)

class OrganizationUpdate(BaseModel):
    name: Optional[str] = Field(None, min_length=1, max_length=100)

class OrganizationMemberAdd(BaseModel):
    user_id: PyObjectId # The internal _id of the User to add
    role: UserRoleEnum = UserRoleEnum.MEMBER # Default role when adding

class OrganizationMemberRoleUpdate(BaseModel):
    role: UserRoleEnum

# Models for populated responses
class PopulatedMember(BaseModel):
    id: str
    name: str
    email: str
    picture: Optional[str] = None
    role: UserRoleEnum

class OrganizationWithPopulatedMembers(Organization):
    members: List[PopulatedMember] = []

class TeamMemberAdd(BaseModel):
    user_id: PyObjectId # The internal _id of the User to add
    role: UserRoleEnum = UserRoleEnum.MEMBER # Default role when adding

class TeamMemberRoleUpdate(BaseModel):
    role: UserRoleEnum

class TeamCreate(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)
    organization_id: PyObjectId
    description: Optional[str] = None

class TeamUpdate(BaseModel):
    name: Optional[str] = Field(None, min_length=1, max_length=100)
    description: Optional[str] = None

class ServiceCreate(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)
    organization_id: PyObjectId # Now required
    description: Optional[str] = None
    status: ServiceStatusEnum = ServiceStatusEnum.OPERATIONAL
    tags: List[str] = []

class ServiceUpdate(BaseModel):
    name: Optional[str] = Field(None, min_length=1, max_length=100)
    description: Optional[str] = None
    status: Optional[ServiceStatusEnum] = None
    tags: Optional[List[str]] = None

class IncidentCreate(BaseModel):
    title: str = Field(..., min_length=1, max_length=200)
    organization_id: PyObjectId
    status: IncidentStatusEnum = IncidentStatusEnum.INVESTIGATING
    severity: IncidentSeverityEnum = IncidentSeverityEnum.MINOR
    affected_services: List[PyObjectId]
    initial_update_message: Optional[str] = None
    is_maintenance: bool = False
    scheduled_start_time: Optional[datetime] = None
    scheduled_end_time: Optional[datetime] = None

class IncidentUpdateAction(BaseModel):
    title: Optional[str] = Field(None, min_length=1, max_length=200)
    status: Optional[IncidentStatusEnum] = None
    severity: Optional[IncidentSeverityEnum] = None
    affected_services: Optional[List[PyObjectId]] = None
    message: Optional[str] = Field(None, min_length=1) # A new update message to append to the list

class IncidentUpdatePayload(BaseModel):
    message: str

class IncidentStatusUpdate(BaseModel):
    status: IncidentStatusEnum

class SubscriberCreate(BaseModel):
    email: EmailStr
    organization_id: PyObjectId

# Metric Models
class Metric(MongoBaseModel):
    service_id: PyObjectId
    value: float
    timestamp: datetime = Field(default_factory=datetime.utcnow)

class MetricCreate(BaseModel):
    service_id: PyObjectId
    value: float

class MetricDataPoint(BaseModel):
    timestamp: datetime
    value: float
